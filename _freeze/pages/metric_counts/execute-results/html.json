{
  "hash": "a96d2058f4c6229463fb1090dd5bc43b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Metric Counts\"\nformat:\n  html:\n    fig-dpi: 200\neditor_options: \n  chunk_output_type: console\nwarnings: false\neval: false\n---\n\n::: {.cell}\n\n:::\n\n\n\nHere we will see how much the dimension scores for Vermont change when we reduce certain indicators with many metrics to a single metric. We do this for an indicator in every dimension except social, which really doesn't have any metrics to spare currently. \n\nNote that this should be redone more systematically and across all metrics to compare them at some point, rather than a picking just a few. On to-do list. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data for aggregations\nstate_key <- readRDS('data/sm_data.rds')[['state_key']]\nmetrics_df <- readRDS('data/metrics_df.rds')\nnormed_data <- readRDS('data/normalized_metrics_df.rds')\nframework <- readRDS('data/filtered_frame.rds')\n\n# Test out process\noriginal_scores <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df\n)\n```\n:::\n\n\n\n# Reduce Physical Health Metrics\n\nFirst let's take the `physical health tbd` indicator and reduce it to only `lifeExpectancy`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove everything from physical health tbd except life expectancy\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'physical health tbd', \n    variable_name != 'lifeExpectancy'\n  ) %>% \n  dplyr::pull(variable_name)\n\n# Get dimension scores\nto_life <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n```\n:::\n\n\n\nNow the same for `drugOverdoseDeaths`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove everything from physical health tbd except life expectancy\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'physical health tbd', \n    variable_name != 'drugOverdoseDeaths'\n  ) %>% \n  pull(variable_name)\n\n# Get dimension scores\nto_overdose <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n```\n:::\n\n\n\nFinally, we can compare the health dimension score and rank for the original framework against the `physical health tbd` indicator as represented by only life expectancy or only drug overdoses.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- map_dfr(list(original_scores, to_life, to_overdose), ~ {\n  .x$minmax_geometric$dimension_scores %>% \n    as.data.frame() %>%\n    dplyr::filter(str_length(state) == 2) %>% \n    mutate(\n      rank = dense_rank(health),\n    ) %>% \n    dplyr::filter(state == 'VT') %>% \n    dplyr::select(health, rank)\n}) %>% \n  mutate(\n    health = round(health, 3),\n    iteration = c('Original', 'Life Exp Only', 'Overdoses Only')\n  )\n```\n:::\n\n::: {.cell class='centered-table'}\n\n:::\n\n\n\n# Reduce Crop Failure Metrics\n\nFor `production`, we will reduce the `crop failure` indicator to only the value of dairy margin protection payments and then income from insurance indemnities.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_str(normed_data)\nget_str(framework)\n\n## Reduce crop failure indicator to totalValueDairyMarginProtPayments\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'crop failure', \n    variable_name != 'totalValueDairyMarginProtPayments'\n  ) %>% \n  pull(variable_name)\n\n# Get dimension scores\nto_dairy <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n\n\n## Reduce crop failure indicator to totalIncomeInsuranceIndemnities\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'crop failure', \n    variable_name != 'totalIncomeInsuranceIndemnities'\n  ) %>% \n  pull(variable_name)\n\n# Get dimension scores\nto_insurance <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n\n\n## Put them together\nprod_df <- map_dfr(list(original_scores, to_dairy, to_insurance), ~ {\n  .x$minmax_geometric$dimension_scores %>% \n    as.data.frame() %>%\n    dplyr::filter(str_length(state) == 2) %>% \n    mutate(\n      rank = dense_rank(production),\n    ) %>% \n    dplyr::filter(state == 'VT') %>% \n    dplyr::select(production, rank)\n}) %>% \n  mutate(\n    production = round(production, 3),\n    iteration = c('Original', 'Dairy Only', 'Insurance Only')\n  )\n```\n:::\n\n::: {.cell class='centered-table'}\n\n:::\n\n\n\n# Reduce Biodiversity Metrics\n\nNow for the `environment` dimension, we will reduce the `biodiversity` indicator from its current set of 8 species down to the percentage of animal species at risk and the percentage of plant species at risk. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_str(normed_data)\nget_str(framework)\n\n## Reduce crop failure indicator to pctAtRiskAnimalSpp\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'biodiversity', \n    variable_name != 'pctAtRiskAnimalSpp'\n  ) %>% \n  pull(variable_name)\n\n# Get dimension scores\nto_animal <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n\n\n## Reduce biodiversity indicator to pctAtRiskPlantSpp\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'crop failure', \n    variable_name != 'pctAtRiskPlantSpp'\n  ) %>% \n  pull(variable_name)\n\n# Get dimension scores\nto_plant <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n\n\n## Put them together\nenv_df <- map_dfr(list(original_scores, to_animal, to_plant), ~ {\n  .x$minmax_geometric$dimension_scores %>% \n    as.data.frame() %>%\n    dplyr::filter(str_length(state) == 2) %>% \n    mutate(\n      rank = dense_rank(environment),\n    ) %>% \n    dplyr::filter(state == 'VT') %>% \n    dplyr::select(environment, rank)\n}) %>% \n  mutate(\n    environment = round(environment, 3),\n    iteration = c('Original', 'Animal Spp Only', 'Plant Spp Only')\n  )\n```\n:::\n\n::: {.cell class='centered-table'}\n\n:::\n\n\n\n# Reduce Wealth/Income Metrics\n\nFor the `economics` dimension, we will reduce the `wealth/income distribution` indicator down to unemployment rate and then gini index.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_str(normed_data)\nget_str(framework)\n\n## Reduce wealth/income indicator to unemploymentRate\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'wealth/income distribution', \n    variable_name != 'unemploymentRate'\n  ) %>% \n  pull(variable_name)\n\n# Get dimension scores\nto_unemployment <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n\n\n## Reduce wealth/income indicator to gini index\nto_remove <- framework %>% \n  dplyr::filter(\n    indicator == 'wealth/income distribution', \n    variable_name != 'gini'\n  ) %>% \n  pull(variable_name)\n\n# Get dimension scores\nto_gini <- get_all_aggregations(\n  normed_data = normed_data['minmax'],\n  framework = framework,\n  state_key = state_key,\n  metrics_df = metrics_df,\n  to_remove = to_remove\n)\n\n\n## Put them together\necon_df <- map_dfr(list(original_scores, to_unemployment, to_gini), ~ {\n  .x$minmax_geometric$dimension_scores %>% \n    as.data.frame() %>%\n    dplyr::filter(str_length(state) == 2) %>% \n    mutate(\n      rank = dense_rank(economics),\n    ) %>% \n    dplyr::filter(state == 'VT') %>% \n    dplyr::select(economics, rank)\n}) %>% \n  mutate(\n    economics = round(economics, 3),\n    iteration = c('Original', 'Unemployment', 'Gini')\n  )\n```\n:::\n\n::: {.cell class='centered-table'}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}