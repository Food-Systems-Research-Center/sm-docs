---
title: Correlations
---

## Introduction {#sec-intro}

Talking points:

* Interactions are important
* Probably cite Kate Schneider [@schneider2023StateFoodSystems] 
* Something about causal models and Allen and Prosperi [@allen2016ModelingSustainableFood].

## Correlation Heatmap

First we have some data wrangle to do. Here, we choose a selection of 35 variables to work with. We also filter for the Connecticut governing regions rather than counties. Finally, we arrange the variables in sensible order so they appear in similar blocks on the correlation plot.

```{r}
#| label: clean_data

pacman::p_load(
  dplyr,
  tidyr,
  tibble,
  stringr,
  purrr
)

source('dev/data_pipeline_functions.R')
source('dev/filter_fips.R')
dat <- readRDS('data/sm_data.rds')[['metrics']]

# What variables should we use?
# First let's just take the last year of everything
dat <- dat %>%
  filter_fips(scope = 'new') %>% 
  get_latest_year()

# Put together a matching pattern for a selection of relevant variables
pattern <- paste0(c(
  '^agri', 'd2c', '^edu', '^groc', 'insecurity', 'median_rent$', '^female',
  'median_rent_as_perc', '^n_house', '^number_', 'refrig', 'pth$', '_pct$',
  '^wic', '^hired', '^total', '^womens_earnings_as_perc', 'vacancy'
  ), collapse = '|')

# Filter by variables, break out variables into separate columns, and make some variable names shorter so they fit in figures
dat <- dat %>%
  filter(str_detect(variable_name, pattern)) %>%
  pivot_wider(
    names_from = 'variable_name',
    values_from = 'value'
  ) %>%
  dplyr::rename(
    womens_earnings_perc_men_fff_2023 = womens_earnings_as_perc_of_men_farming_fishing_forestry_2023,
    womens_earnings_perc_men_service_2023 = 
    womens_earnings_as_perc_of_men_food_prep_and_serving_2023
  )

# Arrange variables in a sensible order by group
# Housing, income, education, food security, infrastructure, localness, total sales, expenses
dat <- dat %>% 
  select(
    matches('_rent_|vacancy'),
    matches('income|earnings'),
    matches('education'),
    matches('insecurity|^wic|^snap'),
    matches('^number|^groc'),
    matches('agritourism|market|_csa_|d2c|valueadded|local_sales'),
    matches('total_|^hired|producer')
  )
```

Now we can build an interactive correlation plot. We are calculating correlations based on complete pairwise observations to account for missing data and the changes to Census Bureau reporting for Connecticut.

::: {.callout-note collapse='true' title='On Missing Data'}
This is a reminder to do a deeper dive on missing data once more of the data have been wrangled. There is a substantial amount given the varying scales at which data are collected, not to mention the issues at the county level with Connecticut.
:::

```{r fig.align='center'}
#| label: correlation_plot
#| fig-cap: Interactive Correlation Plot
#| warning: false

pacman::p_load(
  dplyr,
  ggplot2,
  plotly,
  reshape,
  Hmisc,
  viridisLite
)

# Make a correlation matrix using all the selected variables
cor <- dat %>% 
  as.matrix() %>% 
  rcorr()

# Melt correlation values and rename columns
cor_r <- melt(cor$r) %>% 
  setNames(c('var_1', 'var_2', 'value'))

# Save p values
cor_p <- melt(cor$P) 
p.value <- cor_p$value

# Make heatmap with custom text aesthetic for tooltip
plot <- cor_r %>% 
  ggplot(aes(var_1, var_2, fill = value, text = paste0(
  'Var 1: ', var_1, '\n',
  'Var 2: ', var_2, '\n',
  'Correlation: ', format(round(value, 3), nsmall = 3), '\n',
  'P-Value: ', format(round(p.value, 3), nsmall = 3)
))) + 
  geom_tile() + 
  scale_fill_viridis_c() + 
  theme(axis.text.x = element_text(hjust = 1, angle = 45)) +
  labs(
    x = NULL,
    y = NULL,
    fill = 'Correlation'
  )

# Convert to interactive plotly figure with text tooltip
ggplotly(
  plot, 
  tooltip = 'text',
  width = 1000,
  height = 800
)
```

I am in the midst of an argument with Quarto about formatting plotly graphs. I want this to show its full extent without the scroll bar, but it refuses. Will revisit this.

## Edge Bundling Diagram

I would like to including a bundling diagram as a broader overview of how metrics are related. This is trickier than I expected though. I might leave it at the heat map above.

This is example code: 

```{r eval=FALSE}

# Libraries
library(ggraph)
library(igraph)
library(tidyverse)
 
# create a data frame giving the hierarchical structure of your individuals
set.seed(1234)
d1 <- data.frame(from="origin", to=paste("group", seq(1,10), sep=""))
d2 <- data.frame(from=rep(d1$to, each=10), to=paste("subgroup", seq(1,100), sep="_"))
hierarchy <- rbind(d1, d2)
 
# create a dataframe with connection between leaves (individuals)
all_leaves <- paste("subgroup", seq(1,100), sep="_")
connect <- rbind( 
  data.frame( from=sample(all_leaves, 100, replace=T) , to=sample(all_leaves, 100, replace=T)), 
  data.frame( from=sample(head(all_leaves), 30, replace=T) , to=sample( tail(all_leaves), 30, replace=T)), 
  data.frame( from=sample(all_leaves[25:30], 30, replace=T) , to=sample( all_leaves[55:60], 30, replace=T)), 
  data.frame( from=sample(all_leaves[75:80], 30, replace=T) , to=sample( all_leaves[55:60], 30, replace=T)) )
connect$value <- runif(nrow(connect))
 
# create a vertices data.frame. One line per object of our hierarchy
vertices  <-  data.frame(
  name = unique(c(as.character(hierarchy$from), as.character(hierarchy$to))) , 
  value = runif(111)
) 
# Let's add a column with the group of each name. It will be useful later to color points
vertices$group  <-  hierarchy$from[ match( vertices$name, hierarchy$to ) ]
 
 
# Create a graph object
mygraph <- graph_from_data_frame( hierarchy, vertices=vertices )
 
# The connection object must refer to the ids of the leaves:
from  <-  match( connect$from, vertices$name)
to  <-  match( connect$to, vertices$name)
 

p <- ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
  geom_node_point(aes(filter = leaf, x = x*1.05, y=y*1.05)) +
  theme_void()



# Use the 'value' column of the connection data frame for the color:
p +  geom_conn_bundle(data = get_con(from = from, to = to), aes(colour=value, alpha=value)) 
 
# In this case you can change the color palette
p +  
  geom_conn_bundle(data = get_con(from = from, to = to), aes(colour=value)) +
  scale_edge_color_continuous(low="white", high="red")
p +  
  geom_conn_bundle(data = get_con(from = from, to = to), aes(colour=value)) +
  scale_edge_colour_distiller(palette = "BuPu")
 
# Color depends of the index: the from and the to are different
p +  
  geom_conn_bundle(data = get_con(from = from, to = to), width=1, alpha=0.2, aes(colour=..index..)) +
  scale_edge_colour_distiller(palette = "RdPu") +
  theme(legend.position = "none")



```

And an attempt at doing it for the SM framework:

```{r eval=FALSE}

cor_dat <- cor_r %>% 
  mutate(across(c(1:2), as.character)) %>% 
  filter(var_1 != var_2) %>% 
  rowwise() %>%
  mutate(pair = paste(sort(c(var_1, var_2)), collapse = "_")) %>%
  ungroup() %>%
  distinct(pair, .keep_all = TRUE) %>%
  select(-pair)
get_str(cor_dat)


## Vertices
# Need a vertices data frame with every leaf. The example provides a random value as well, but I don't think we need this.
# Example:
vertices

# Make it:
vert <- data.frame(
  name = unique(c(cor_dat$var_1, cor_dat$var_2)),
  group = '1',
  value = runif(35)
) %>% 
  bind_rows(c(name = 'origin', group = NA_character_))


## Hierarchy
hierarchy
# Do we really need this? I don't care about groups
# Try making it with a single group. Pull it from cor_r
hier <- data.frame(
  from = 'origin',
  to = vert$name
)


## Connections
connect
# cor_dat is this already, just clean it up
con <- cor_dat %>% 
  setNames(c('from', 'to', 'value'))



## Graph
# Create a graph object
mygraph <- graph_from_data_frame(hier, vertices = vert)
 
# The connection object must refer to the ids of the leaves:
from  <-  match( con$from, vert$name)
to  <-  match( con$to, vert$name)
 


p <- ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
  geom_node_point(aes(filter = leaf, x = x*1.05, y=y*1.05)) +
  theme_void()




# Use the 'value' column of the connection data frame for the color:
p +  geom_conn_bundle(
  data = get_con(from = from, to = to), 
  aes(
    # colour = value, 
    alpha = value
  )
) 
 
# In this case you can change the color palette
p +  
  geom_conn_bundle(data = get_con(from = from, to = to), aes(colour=value)) +
  scale_edge_color_continuous(low="white", high="red")
p +  
  geom_conn_bundle(data = get_con(from = from, to = to), aes(colour=value)) +
  scale_edge_colour_distiller(palette = "BuPu")
 
# Color depends of the index: the from and the to are different
p +  
  geom_conn_bundle(data = get_con(from = from, to = to), width=1, alpha=0.2, aes(colour=..index..)) +
  scale_edge_colour_distiller(palette = "RdPu") +
  theme(legend.position = "none")

```

Here is the kind of thing I'd like to make, where stronger correlations are brighter and the links between groups are clearer:

![edge_bundle](../images/edge_bundling.png){width=100%}

## References

