---
title: "Framework"
execute:
    cache: true
---

This is where the framework will be described. Cite some papers doing similar work, maybe better explain the gap a little bit. Then use some big picture visualization below to get the gist across. More detail about dimensions, indices, and metrics will be in the following pages.

## Radial Plot

```{r fig.dim=c(10, 10), fig.align='center'}
#| label: radial_plot
#| fig-cap: Radial plot of Sustainability Metrics framework
#| code-fold: true
#| warning: false

## Load packages
pacman::p_load(
  ggraph,
  igraph,
  dplyr,
  RColorBrewer,
  viridisLite
)


## Load data and add an origin level
dat <- readRDS('data/tree_dat.rds') %>% 
  dplyr::mutate(Framework = 'Sustainability') %>% 
  dplyr::select(Framework, Dimension:Indicator)


## Make edges
# include groupings by dimension, then combine them
edges <- list()
edges$sm_dim <- dat %>% 
  dplyr::select(Framework, Dimension) %>% 
  unique() %>% 
  dplyr::rename(from = Framework, to = Dimension) %>% 
  mutate(group = to)
edges$dim_ind <- dat %>% 
  dplyr::select(Dimension, Index) %>% 
  unique() %>% 
  dplyr::rename(from = Dimension, to = Index) %>% 
  mutate(group = from)
edges$ind_ind <- dat %>% 
  dplyr::select(Index, Indicator) %>% 
  unique() %>% 
  dplyr::rename(from = Index, to = Indicator) %>% 
  mutate(group = edges$dim_ind$from[match(.$from, edges$dim_ind$to)])
edges <- bind_rows(edges)


## Make vertices
# Each line is a single vertex (dimension, index, or indicator)
# We are just giving them random values to control point size for now
vertices = data.frame(
  name = unique(c(as.character(edges$from), as.character(edges$to))) , 
  value = runif(nrow(edges) + 1)
) 

# Add the dimension groupings to the vertices as well
vertices$group = edges$group[match(vertices$name, edges$to)]

# Calculate the angles to arrange indicator labels
vertices$id = NA
myleaves = which(is.na(match(vertices$name, edges$from)))
nleaves = length(myleaves)
vertices$id[myleaves] = seq(1:nleaves)
vertices$angle = 90 - 360 * vertices$id / nleaves

# Calculate alignment of indicator labels
vertices$hjust <- ifelse(vertices$angle < -90, 1, 0)

# Flip label angles around 180 degrees if they are facing the wrong way
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle + 180, vertices$angle)


## Create graph
# Make ggraph object from edges and vertices
graph <- graph_from_data_frame(edges, vertices = vertices)

# Plot the graph
ggraph(graph, layout = 'dendrogram', circular = TRUE) +
  
  # Color edges by dimension
  geom_edge_diagonal(aes(color = group), width = 0.5) +
  
  # Create text for indicators using angles, hjust, and dimension groupings
  geom_node_text(
    aes(
      x = x * 1.15,
      y = y * 1.15,
      filter = leaf,
      label = name,
      angle = angle,
      hjust = hjust,
      colour = group
    ),
    size = 2.7,
    alpha = 1
  ) +
  
  # Make the points for indicators based on dimension groupings
  geom_node_point(aes(
    filter = leaf,
    x = x * 1.07,
    y = y * 1.07,
    colour = group,
    size = value,
    alpha = 0.2
  )) +
  
  # Label the dimensions within the graph
  geom_node_label(
    aes(label = ifelse(name == group, name, NA)),
    label.padding = unit(0.2, "lines"),
    label.r = unit(0.3, "lines"),
    label.size = 0.1,
    size = 3
  ) +
  
  # Various formatting options
  scale_colour_manual(values = brewer.pal(5, 'Set1')) +
  scale_edge_color_manual(values = brewer.pal(5, 'Set1')) +
  scale_size_continuous(range = c(0.1, 7)) +
  theme_void() +
  theme(
    legend.position = "none",
    plot.margin = unit(c(0, 0, 0, 0), "cm")
  ) +
  expand_limits(x = c(-2, 2), y = c(-2, 2))
```

Note that the size of the leaf nodes doesn't actually mean anything right now - they are just randomly generated. Eventually we could weight this by eigenvalues within dimensions.

## Phylogeny

Here is a more practical but less visually appealing version of the same framework. Still kind of a monster. **To do: fix the color scheme so it is colored by dimension and matches the radial plot above.**

```{r}
#| label: tree
#| fig-cap: Phylogeny tree diagram
#| fig-height: 20
#| fig-width: 8
pacman::p_load(
  ggtree,
  dplyr,
  ape,
  data.tree,
  viridisLite,
  stringr
)

## Load data and add an origin level
dat <- readRDS('data/tree_dat.rds') %>% 
  mutate(Framework = 'Sustainability') %>% 
  dplyr::select(Framework, Dimension:Indicator) %>% 
  mutate(across(
    everything(), 
    ~ str_trim(str_replace_all(., ';|%|/|\\.|\"|,|\\(|\\)', '_'))
  ))
# print(dat, n = 100)
# get_str(dat)

dat$pathString <- paste(
  dat$Framework,
  dat$Dimension,
  dat$Index,
  dat$Indicator,
  sep = '/'
)
tree <- as.Node(dat)

# Convert the data.tree structure to Newick format
tree_newick <- ToNewick(tree)

# Read the Newick tree into ape
phylo_tree <- read.tree(text = tree_newick)

# Make all edge lengths 1
phylo_tree$edge.length <- rep(1, length(phylo_tree$edge.length))

# Add a space to end of node labels so it isn't cut off
phylo_tree$node.label <- paste0(phylo_tree$node.label, ' ')

# Plot it
plot(
  phylo_tree, 
  type = 'c',
  cex = 0.75,
  edge.width = 2,
  show.tip.label = TRUE,
  label.offset = 0,
  no.margin = TRUE,
  tip.color = 'black',
  edge.color = viridis(181),
  x.lim = c(-0.1, 5)
)

nodelabels(
  phylo_tree$node.label,
  cex = 0.8,
  bg = 'white'
)

```

