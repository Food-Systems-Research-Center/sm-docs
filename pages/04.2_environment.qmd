---
title: "Environment"
fig-responsive: false
---

```{r}
#| label: setup
#| include: false
pacman::p_load(
 conflicted
)

conflicts_prefer(
 dplyr::select(),
 dplyr::filter(),
 .quiet = TRUE
)
```

## Dimension Overview

The first plot shows all the environment indicators from both the current studies and the original framework in the y-axis. Purple indicates that the indicator is only being used in the current studies, orange that it is only included in the Wiltshire framework, and green that the indicator is used in both the framework and current studies.

The x-axis shows the number of secondary data metrics that have been collected to represent those indicators. You can see that there are some indicators for which there exist many data, but many indicators for which I have found little to represent them. 

NASS figures are used to cover on-farm water use, energy efficiency, and acres in conservation practices. I used the National Aquatic Resource Surveys aggregated at the state level to measure water quality. Land use diversity is pretty well represented by Multi-Resolution Land Characteristics LULC layers, which I also aggregated at the county level. Greenhouse gas emissions come from EPA figures by state, broken down by economic sector. Finally, the USFS TreeMap dataset accounts for aboveground biomass and would do reasonably well in tree vigor. There is more to pull out here than I have so far.

Otherwise, if anyone has ideas for secondary datasets to cover the rest of the indicators, please do let me know.

```{r}
#| label: barplot
#| fig-cap: Bar Plot of Indicators
#| warning: false
#| fig-align: center
pacman::p_load(
  dplyr,
  ggplot2,
  stringr,
  plotly,
  RColorBrewer
)

## Load data for tree and metrics
env_tree <- readRDS('data/trees/env_tree.rds')

meta <- readRDS('data/sm_data.rds')[['metadata']] %>% 
  filter(dimension == 'environment')

# Format to match Wiltshire framework
meta <- meta %>% 
  mutate(
    indicator = str_to_sentence(indicator),
    indicator = case_when(
      str_detect(indicator, '^Above') ~ 'Aboveground biomass',
      str_detect(indicator, '^Water') ~ 'Water use / irrigation efficiency',
      TRUE ~ indicator
    )
  ) 

# Counts of secondary data metrics
counts <- meta %>% 
  group_by(indicator) %>% 
  dplyr::summarize(count = n())

# Join to Wiltshire framework
colors <- RColorBrewer::brewer.pal(n = 3, name = 'Dark2')
dat <- full_join(env_tree, counts, by = join_by(Indicator == indicator)) %>% 
  mutate(
    count = ifelse(is.na(count), 0, count),
    label_color = case_when(
      Use == 'both' ~ colors[1],
      Use == 'wiltshire_only' ~ colors[2],
      Use == 'current_only' ~ colors[3]
    )
  )

# Plot
dat %>%
  ggplot(aes(x = Indicator, y = count)) +
  geom_col(
    color = 'black',
    fill = 'grey'
  ) +
  geom_point(
    data = dat,
    aes(x = 1, y = 1, color = Use),
    inherit.aes = FALSE
  ) +
  scale_color_manual(
    name = "Indicator Use:",
    values = c(
      "both" = colors[1],
      "current_only" = colors[3],
      "wiltshire_only" = colors[2]
    ),
    labels = c(
      'Both',
      'Current Only',
      'Framework Only'
    )
  ) +
  theme_classic() +
  theme(
    axis.text.y = element_text(color = dat$label_color),
    legend.position = "bottom",
    plot.margin = margin(t = 10, r = 75, b = 10, l = 10)
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 3))
  ) +
  coord_flip() +
  labs(y = 'Secondary Data Count')
```

## Maps

Taking a quick tour through some of the spatial data here. I'm not including full rasters of LULC or TreeMap layers to conserve space, but I have included some derived metrics by county. With the exception of hotspot and species atlas data, these will also be up on the Shiny app along with all the other metrics.

### Land Use Diversity

This is derived from the USGS MRLC 30m LULC layer for 2023. LULC types are aggregated by category (water, developed, barren, forest, shrubland, herbaceous, cultivated, wetlands) and Shannon diversity is calculated for each county.

```{r}
#| label: lulc
#| fig-cap: Land Use Land Cover Diversity
#| out.width: 100%
pacman::p_load(
  mapview,
  dplyr,
  sf,
  leaflet,
  leafpop,
  viridisLite
)

div <- readRDS('data/sm_data.rds')[['lulc_div']]

mapview(
  div,
  zcol = 'lulc_div',
  label = 'county_name',
  layer.name = 'LULC Diversity',
  popup = popupTable(
    div,
    zcol = c(
      'county_name',
      'lulc_div'
    ),
    row.numbers = FALSE,
    feature.id = FALSE
  )
)
```

<!-- ### Species Atlas -->

<!-- The next couple of maps are not only ancient, but can't easily be aggregated at the county level. I'm all ears if folks know if better datasets out there that cover biodiversity across New England. -->

<!-- The species atlas has counts of plant and animal species by town. Apart from being pretty far out of date (2000), we can't aggregate by county or state without having more granular data. -->


<!-- ```{r} -->
<!-- #| label: species_atlas -->
<!-- #| fig-cap: Species Atlas -->
<!-- #| out.width: 100% -->
<!-- pacman::p_load( -->
<!--   mapview, -->
<!--   dplyr, -->
<!--   sf, -->
<!--   viridisLite, -->
<!--   leaflet, -->
<!--   leafpop -->
<!-- ) -->

<!-- atlas <- readRDS('data/sm_data.rds')[['atlas']] -->

<!-- atlas <- atlas %>% -->
<!--   select(-starts_with('SHAPEST')) %>% -->
<!--   dplyr::rename( -->
<!--     TOWN = TOWNNAME, -->
<!--     BRYOPHYTE = BRYOP, -->
<!--     MAMMAL = MAMML -->
<!--   ) %>% -->
<!--   mutate( -->
<!--     TOTAL_SPP = rowSums(across(c( -->
<!--       PLANT, BRYOPHYTE, FERN, TREE, HERP, MAMMAL, FISH -->
<!--   ))) -->
<!-- ) -->

<!-- mapview( -->
<!--   atlas, -->
<!--   zcol = 'TOTAL_SPP', -->
<!--   layer.name = 'Species<br>Richness', -->
<!--   label = 'TOWN', -->
<!--   popup = popupTable( -->
<!--     atlas, -->
<!--     zcol = c( -->
<!--       'TOWN', -->
<!--       'PLANT', -->
<!--       'BRYOPHYTE', -->
<!--       'FERN', -->
<!--       'TREE', -->
<!--       'HERP', -->
<!--       'MAMMAL', -->
<!--       'FISH', -->
<!--       'TOTAL_SPP' -->
<!--     ) -->
<!--   ) -->
<!-- ) -->
<!-- ``` -->


### Biodiversity Hotspots

Again, this biodiversity hotspot map was being put together around the same time as the Y2k crisis. Even if this were more recent and throughout New England, incoporating this kind of data into the framework seems a bit fraught.

```{r}
#| label: hotspots
#| fig-cap: Biodiversity Hotspots Map
#| out.width: 100%
hotspots <- readRDS('data/sm_data.rds')[['hotspots']]
mapview(hotspots, col.regions = '#154734')

```

### Forest Biomass

The TreeMap 2016 dataset is quite comprehensive national survey of forest health and diversity. Updates are infrequent, but this is the best layer I've found to address biomass. The raster is at 30m. Shown below is the mean live above-ground biomass aggregated by county so that it plays well with other metrics. Note that it is measured in tons *per acre of forest*, non-forest cells were removed from analysis. So, it is not showing density of forest, just biomass in existing forest. This is why the more urban counties still show a reasonable density of live biomass. There is lots more that can be pulled out of this dataset, like dead/down carbon, tree stocking, live canopy cover, height, volume, tree per acre, etc. More info can be found [here](https://research.fs.usda.gov/treesearch/65597).

```{r}
#| label: biomass
#| fig-cap: Map of aboveground forest biomass by county
#| out.width: 100%
pacman::p_load(
  mapview,
  dplyr,
  sf,
  viridisLite,
  leaflet,
  leafpop
)
biomass <- readRDS('data/sm_data.rds')[['mean_biomass']]
mapview(
  biomass,
  zcol = 'mean_biomass',
  layer.name = 'Mean Live Above<br>Ground Biomass<br>(tons per acre)',
  label = 'county_name',
  popup = popupTable(
    biomass,
    zcol = c(
      'county_name',
      'mean_biomass'
    ),
    feature.id = FALSE,
    row.numbers = FALSE
  )
)
```

## Metadata Table

This table includes all secondary data metrics. Filter by dimension to get just environment metrics.

Using the table: 

* Click column headers to sort
* Global search in the top right, or column search in each header
* Change page length and page through results at the bottom
* Use the download button to download a .csv file of the filtered table
* Click the arrow on the left of each row for details, including a URL to the data source.

```{r}
#| label: metadata_table
#| warning: false

pacman::p_load(
  dplyr,
  reactable,
  stringr,
  htmltools
)

# Load full metadata table
metadata_all <- readRDS('data/sm_data.rds')[['metadata']]

# Pick out variables to display
metadata <- metadata_all %>% 
  select(
    metric,
    'Variable Name' = variable_name,
    definition,
    dimension,
    index,
    indicator,
    units,
    'Year' = latest_year, # Renaming latest year as year, not including og year
    source,
    scope,
    resolution,
    url
) %>% 
  setNames(c(str_to_title(names(.))))

###
htmltools::browsable(
  tagList(
    
    tags$div(
      style = "display: flex; gap: 16px; margin-bottom: 20px; justify-content: center;",
      
      tags$button(
        class = "btn btn-primary",
        style = "display: flex; align-items: center; gap: 8px; padding: 8px 12px;",
        tagList(fontawesome::fa("download"), "Show/hide more columns"),
        onclick = "Reactable.setHiddenColumns('metadata_table', prevColumns => {
          return prevColumns.length === 0 ? ['Definition', 'Scope', 'Resolution', 'Url'] : []
        })"
      ),
      
      tags$button(
        class = "btn btn-primary",
        style = "display: flex; align-items: center; gap: 8px; padding: 8px 12px;",
        tagList(fontawesome::fa("download"), "Download as CSV"),
        onclick = "Reactable.downloadDataCSV('metadata_table', 'sustainability_metadata.csv')"
      )
    ),
    
    reactable(
      metadata,
      sortable = TRUE,
      resizable = TRUE,
      filterable = TRUE,
      searchable = TRUE,
      pagination = TRUE,
      bordered = TRUE,
      wrap = TRUE,
      rownames = FALSE,
      onClick = 'select',
      striped = TRUE,
      pageSizeOptions = c(5, 10, 25, 50, 100),
      defaultPageSize = 5,
      showPageSizeOptions = TRUE,
      highlight = TRUE,
      style = list(fontSize = "14px"),
      compact = TRUE,
      columns = list(
        Metric = colDef(
          minWidth = 200,
          sticky = 'left'
        ),
        'Variable Name' = colDef(
          minWidth = 150
        ),
        Definition = colDef(
          minWidth = 250
        ),
        'Latest Year' = colDef(minWidth = 75),
        Source = colDef(minWidth = 250),
        Scope = colDef(show = FALSE),
        Resolution = colDef(show = FALSE),
        Url = colDef(
          minWidth = 300,
          show = FALSE
        )
      ),
      defaultColDef = colDef(minWidth = 100),
      elementId = "metadata_table",
      details = function(index) {
        div(
          style = "padding: 15px; border: 1px solid #ddd; margin: 10px 0;
             background-color: #E0EEEE; border-radius: 10px; border-color: black;
             box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);",
          
          tags$h4(
            strong("Details"), 
          ),
          tags$p(
            strong('Metric Name: '), 
            as.character(metadata_all[index, 'metric']),
          ),
          tags$p(
            strong('Variable Name: '), 
            as.character(metadata_all[index, 'variable_name']),
          ),
          tags$p(
            strong('Definition: '), 
            as.character(metadata_all[index, 'definition']),
          ),
          tags$p(
            strong('Source: '), 
            as.character(metadata_all[index, 'source'])
          ),
          tags$p(
            strong('Latest Year: '), 
            as.character(metadata_all[index, 'latest_year'])
          ),
          tags$p(
            strong('All Years (cleaned, wrangled, and included): '), 
            as.character(metadata_all[index, 'year'])
          ),
          tags$p(
            strong('Updates: '), 
            str_to_title(as.character(metadata_all[index, 'updates']))
          ),
          tags$p(
            strong('URL: '), 
            tags$a(
              href = as.character(metadata_all[index, 'url']),
              target = '_blank',
              as.character(metadata_all[index, 'url'])
            )
          )
        )
      }
    )
  )
)

```

## Data Table

```{r}
#| label: metric_table
#| warning: false

pacman::p_load(
  dplyr,
  reactable,
  stringr,
  htmltools
)

# Load metrics and metadata
metadata_all <- readRDS('data/sm_data.rds')[['metadata']]
metrics <- readRDS('data/sm_data.rds')[['metrics']]
fips_key <- readRDS('data/sm_data.rds')[['fips_key']]

# Value formatting function based on units
source('dev/format_values.R')

# Filter to economics metrics, join with metadata and county fips codes
env_metrics <- metrics %>% 
  left_join(metadata_all, by = join_by('variable_name')) %>% 
  filter(dimension == 'environment') %>% 
  left_join(fips_key, by = join_by('fips')) %>% 
  mutate(county_name = ifelse(is.na(county_name), state_name, county_name)) %>% 
  format_values() %>% 
  select(
    metric,
    'Variable Name' = variable_name,
    definition,
    year = year.x,
    Area = county_name,
    units,
    value
  ) %>% 
  setNames(c(str_to_title(names(.)))) %>% 
  filter(!is.na(Value))


## Reactable table
htmltools::browsable(
  tagList(
    
    tags$div(
      style = "display: flex; gap: 16px; margin-bottom: 20px; justify-content: center;",
      tags$button(
        class = "btn btn-primary",
        style = "display: flex; align-items: center; gap: 8px; padding: 8px 12px;",
        tagList(fontawesome::fa("download"), "Download as CSV"),
        onclick = "Reactable.downloadDataCSV('metrics_table', 'sustainability_metrics.csv')"
      )
    ),
    
    reactable(
      env_metrics,
      sortable = TRUE,
      resizable = TRUE,
      filterable = TRUE,
      searchable = TRUE,
      pagination = TRUE,
      bordered = TRUE,
      wrap = TRUE,
      rownames = FALSE,
      onClick = 'select',
      striped = TRUE,
      pageSizeOptions = c(5, 10, 25, 50, 100),
      defaultPageSize = 5,
      showPageSizeOptions = TRUE,
      highlight = TRUE,
      style = list(fontSize = "14px"),
      compact = TRUE,
      columns = list(
        Metric = colDef(
          minWidth = 125,
          sticky = 'left'
        ),
        'Variable Name' = colDef(
          minWidth = 125
        ),
        Definition = colDef(
          minWidth = 250
        ),
        Units = colDef(minWidth = 100),
        'Year' = colDef(minWidth = 100)
      ),
      defaultColDef = colDef(minWidth = 100),
      elementId = "metrics_table"
    )
  )
)

```


## Distribution Plots

### By County

Note that while most of the available secondary data is at the county level, the environment dimension includes a fair amount at the state level as well. This includes greenhouse gas emissions and water quality surveys. For now, I'll just show these separately, but some creative aggregation will have to happen eventually.

```{r}
#| label: dist_plots_county
#| fig-cap: Distributions of economic metrics at the county level.
#| fig-height: 12
#| fig-width: 10
#| fig-align: center
#| warning: false
pacman::p_load(
  dplyr,
  purrr,
  ggplot2,
  rlang,
  ggpubr,
  tidyr
)
source('dev/data_pipeline_functions.R')
source('dev/filter_fips.R')
metrics <- readRDS('data/sm_data.rds')[['metrics']]
metadata <- readRDS('data/sm_data.rds')[['metadata']]

# Use metadata to get help filter by dimension
env_meta <- metadata %>% 
  filter(dimension == 'environment')

# Filter to economics dimension
env_metrics <- metrics %>% 
  filter(variable_name %in% env_meta$variable_name)

# env_metrics$variable_name %>% unique
# get_str(env_metrics)

# Filter to latest year and new (post-2024) counties
# And pivot wider so it is easier to get correlations
env_county <- env_metrics %>%
  filter_fips(scope = 'counties') %>% 
  get_latest_year() %>% 
  select(fips, variable_name, value) %>% 
  mutate(variable_name = str_split_i(variable_name, '_', 1)) %>% 
  pivot_wider(
    names_from = 'variable_name',
    values_from = 'value'
  ) %>% 
  unnest(!fips) %>% 
  mutate(across(c(2:last_col()), as.numeric))
# get_str(env_county)

## Plot
plots <- map(names(env_county)[-1], \(var){
  if (is.character(env_county[[var]])) {
    env_county %>% 
      ggplot(aes(x = !!sym(var))) + 
      geom_bar(
        fill = 'lightblue',
        color = 'royalblue',
        alpha = 0.5
      ) +
      theme_classic() +
      theme(plot.margin = unit(c(rep(0.5, 4)), 'cm'))
  } else if (is.numeric(env_county[[var]])) {
    env_county %>% 
      ggplot(aes(x = !!sym(var))) + 
      geom_density(
        fill = 'lightblue',
        color = 'royalblue',
        alpha = 0.5
      ) +
      theme_classic() +
      theme(plot.margin = unit(c(rep(0.5, 4)), 'cm'))
  } else {
    return(NULL)
  }
}) 


# Arrange them in 4 columns
ggarrange(
  plotlist = plots,
  ncol = 4,
  nrow = 7
)
```

### By State

```{r}
#| label: dist_plots_state
#| fig-cap: Distributions of environmental variables at state level
#| fig-height: 40
#| fig-width: 10
#| fig-align: center
#| warning: false
pacman::p_load(
  dplyr,
  purrr,
  ggplot2,
  rlang,
  ggpubr,
  tidyr
)

state_codes <- readRDS('data/sm_data.rds')[['fips_key']] %>% 
  select(fips, state_code)

env_state <- env_metrics %>%
  filter_fips(scope = 'state') %>% 
  get_latest_year() %>% 
  select(fips, variable_name, value) %>% 
  mutate(variable_name = str_split_i(variable_name, '_', 1)) %>% 
  pivot_wider(
    names_from = 'variable_name',
    values_from = 'value'
  ) %>% 
  unnest(!fips) %>% 
  mutate(across(c(2:last_col()), as.numeric)) %>% 
  left_join(state_codes, by = 'fips')
# get_str(env_state)

# Variables to map. Take out some that didn't come through well.
vars <- names(env_state)[-1] %>% 
  str_subset(
    'lakesAcidCond|lakesCylsperEpaCond|lakesMicxEpaCond|state_code|waterIrrSrcOffFarmExp|waterIrrReclaimedAcreFt|waterIrrReclaimedOpenAcres',
    negate = TRUE
  )

## Plot
plots <- map(vars, \(var){
  env_state %>% 
    ggplot(aes(y = !!sym(var), x = state_code, color = state_code)) + 
    geom_point(
      alpha = 0.5,
      size = 3
    ) +
    theme_classic() +
    theme(
      plot.margin = unit(c(rep(0.5, 4)), 'cm'),
      legend.position = 'none'
    ) +
    labs(
      x = 'State'
    )
}) 

# Arrange them in 4 columns
ggarrange(
  plotlist = plots,
  ncol = 4,
  nrow = 17
)
```


## Bivariate Plots

Using a selection of variables at the county level. The variable names are a bit hard to fit in here, but from left to right across the top they are LULC diversity, mean live above-ground forest biomass, conservation income per farm, conservatino easement acres per farm, conservation tillage: no-till acres per farm, conservation tillage: excluding no-till acres per farm, and cover cropping: excluding CRP acres per farm.

```{r}
#| label: bivariate_plots
#| warning: false
#| out.width: 100%
pacman::p_load(
  GGally
)

# Neat function for mapping colors to ggpairs plots
# https://stackoverflow.com/questions/45873483/ggpairs-plot-with-heatmap-of-correlation-values
map_colors <- function(data,
                       mapping,
                       method = "p",
                       use = "pairwise",
                       ...) {
  # grab data
  x <- eval_data_col(data, mapping$x)
  y <- eval_data_col(data, mapping$y)
  
  # calculate correlation
  corr <- cor(x, y, method = method, use = use)
  colFn <- colorRampPalette(c("blue", "white", "red"), interpolate = 'spline')
  fill <- colFn(100)[findInterval(corr, seq(-1, 1, length = 100))]
  
  # correlation plot
  ggally_cor(data = data, mapping = mapping, color = 'black', ...) +
    theme_void() +
    theme(panel.background = element_rect(fill = fill))
}

lower_function <- function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping) +
    geom_point(alpha = 0.5) +
    geom_smooth(color = "blue", fill = "grey", ...) +
    theme_bw()
}

# Rename variables to be shorter
env_county %>%
  select(
    LULC = lulcDiversity,
    Biomass = meanAboveGrndForBiomass,
    consIncomePF,
    consEasementAcresPF,
    consTillNoTillAcresPF,
    consTillExclNoTillAcresPF,
    coverCropExclCrpAcresPF
  ) %>%
  ggpairs(
    upper = list(continuous = map_colors),
    lower = list(continuous = lower_function),
    axisLabels = 'show'
  ) + 
  theme(
    strip.text = element_text(size =  5),
    axis.text = element_text(size =   5),
    legend.text = element_text(size = 5)
  )
```



## Correlations {#sec-correlations}

Only showing correlations by county because we don't have enough observations to run it by state.

```{r}
#| label: correlation_plot_county
#| fig-cap: Interactive correlation plot of metrics by county
#| warning: false
pacman::p_load(
  dplyr,
  tidyr,
  tibble,
  stringr,
  purrr,
  tidyr,
  ggplot2,
  plotly,
  reshape,
  Hmisc,
  viridisLite
)

# get_str(env_county)

cor <- env_county %>% 
  select(-fips) %>% 
  as.matrix() %>% 
  rcorr()

# Melt correlation values and rename columns
cor_r <- melt(cor$r) %>% 
  setNames(c('var_1', 'var_2', 'value'))

# Save p values
cor_p <- melt(cor$P)
p.value <- cor_p$value

# Make heatmap with custom text aesthetic for tooltip
plot <- cor_r %>% 
  ggplot(aes(var_1, var_2, fill = value, text = paste0(
    'Var 1: ', var_1, '\n',
    'Var 2: ', var_2, '\n',
    'Correlation: ', format(round(value, 3), nsmall = 3), '\n',
    'P-Value: ', format(round(p.value, 3), nsmall = 3)
  ))) + 
  geom_tile() + 
  scale_fill_viridis_c() + 
  theme(axis.text.x = element_text(hjust = 1, angle = 45)) +
  labs(
    x = NULL,
    y = NULL,
    fill = 'Correlation'
  )

# Convert to interactive plotly figure with text tooltip
ggplotly(
  plot, 
  tooltip = 'text',
  width = 1000,
  height = 800
)
```

## PCA

Again, this is only at the county level. First, imputing missing data.

```{r}
#| label: imputation.x
#| warning: false
pacman::p_load(
  missForest
)

# Wrangle dataset. Need all numeric vars or factor vars. And can't be tibble
# Also removing character vars - can't use these in PCA
dat <- env_county %>%
  select(where(is.numeric)) %>%
  as.data.frame()
# get_str(dat)

# Impute missing variables
set.seed(42)
mf_out <- dat %>%
  missForest(
    ntree = 200,
    mtry = 10,
    verbose = FALSE,
    variablewise = FALSE
  )

# Save imputed dataset
imp <- mf_out$ximp

# Print OOB
mf_out$OOBerror

```

```{r}
#| label: vss.x
#| warning: false
pacman::p_load(
  psych
)
VSS(imp)
fa.parallel(imp)
```

VSS suggests 1 or 2 components, MAP suggests 7, parallel analysis shows 2 or 3. Let's go with 3 for now.

```{r}
#| label: pca.x
#| warning: false
(pca_out <- pca(imp, nfactors = 3))

plot(pca_out$values)
abline(h = 1)

```

The scree plot makes a pretty good case for 3 components here as well, as it has a nice elbow after the third.

It looks like the first component is made up of most of the conservation agriculture practices from the NASS datasets, namely acres of conservation tillage, cover cropping, and draining. Fertilizer expenses loads surprisingly strongly here too. The second component seems to have the most to do with county size or population; anything measured by the number of operations does well here, as does mean above-ground forest biomass. The last component is a grab-bag - conservation easement acres load the strongest onto it, but I don't see a coherent pattern among metrics here.

## Analysis

### Imputation

```{r}
#| label: imputation
#| warning: false
pacman::p_load(
  missForest
)
# Wrangle dataset. Need all numeric vars or factor vars. And can't be tibble
# Also removing character vars - can't use these in PCA
# Using old Connecticut counties - some lulc data is missing for them though
dat <- env_county %>%
  filter_fips('old') %>% 
  select(fips, where(is.numeric)) %>%
  column_to_rownames('fips') %>% 
  as.data.frame()
# get_str(dat)
# skimr::skim(dat)

# Remove variables with most missing data - too much to impute.
# Also remove the proportional LULC values - keeping diversity though
dat <- dat %>% 
  select(-matches('consIncome'), -matches('^lulcProp'))

# Impute missing variables
set.seed(42)
mf_out <- dat %>%
  missForest(
    ntree = 200,
    mtry = 10,
    verbose = FALSE,
    variablewise = FALSE
  )

# Save imputed dataset
imp <- mf_out$ximp

# Print OOB
mf_out$OOBerror

```


### Normalization

Using min-max normalization to put all indicators on an arbitrary 0-1 scale

```{r}
#| label: normalization
#| warnings: false
# get_str(imp)

# Function to normalize data
normalize <- function(x) {
    (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}

# Normalize all variables
dat <- map_dfc(imp, normalize)
```

Now that we have normalized variables, we have to make normative decisions about what constitutes a good or bad value of those variables. This will eventually be a collaborative process where we will seek input from teams to come to some kind of consensus. But until then, I'm going to make some heroic assumptions that LULC diversity is good, above ground forest biomass is good, conservation practices and easements are good, and fertilizer expenses are bad. Open to thoughts here as always.

With that, we can recode our normalized variables accordingly.

```{r}
#| label: norms
# Flip 'bad' variables by subtracting them from 1
normed <- dat %>% 
  mutate(across(c(matches('^fert')), ~ 1 - .x))
# get_str(normed)
```

### Component Extraction

Determine the number of components to extract using a few tools: very simple structure (VSS), Velicer's minimum average partial (MAP) test, parallel analysis, and a scree plot.

```{r}
#| label: extraction
#| warning: false
pacman::p_load(
  psych
)
VSS(normed)
fa.parallel(normed)
pca_out <- pca(normed, nfactors = 3, rotate = 'varimax')
plot(pca_out$values)
abline(h = 1)
```

This scree plot shows the eigenvalues (variance explained) of each principal component (y-axis) against each component (x-axis). The first few components explain lots of variance, but there is a decent elbow around the fourth component.

VSS suggests 1 or 2, MAP suggests 8, parallel analysis shows 3. I'm going with 3 here, which will be explained further below.

### Principal Components Analysis

Using an oblique varimax rotation that allows for correlations between principal components. First we just observe the scree plot to see how the components play out.

```{r}
#| label: pca_scree
#| warning: false
pca_out <- pca(normed, nfactors = 3, rotate = 'varimax')
plot(pca_out$values)
abline(h = 1)
```

Now we let's look at PCA results.

```{r}
#| label: pca
#| warnings: false
pca_out
```

Recommendations for creating composite indices are to extract components that each have eigenvalues > 1, explained variance > 0.10, and such that the proportion of explained variance for the total set is > 0.60 [@nicolettiSummaryIndicatorsProduct2000; @oecdHandbookConstructingComposite2008]. 

Our total cumulative variance is explained is 0.74, and our component that explains the least variance is RC4 with 0.11. Note that extracting four or more components here gives us a component with less than 0.10, so this is why we are sticking to three. The first component (RC1) explains 38% of the variance in the data. The second component is respectable at 0.26, while the third is barely above the threshold at 0.11.

Looking at the metrics, we can see that the first component loads mostly onto the conservation practices, no-till acres, cover cropping, drainage, and total fertilizer expenses. The second component leads onto mean aboveground biomass (although there is crossloading with the first component), operations wtih silvapasture, operations with easements, rotational grazing operations, and operations with fertilizer expenses. This seems to be catching more of the population-related metrics. The last component only loads onto a few metrics: easement acres, easement acres per farm, and silvpasture operations (which has some heavy crossloading). 

### Aggregation

To aggregate data by county, we can use loadings to weight metrics and proportion of unique variance explained to weight components. Here, we extract those loadings and calculate the normalized sum of square factor loadings to weight each component.

```{r}
#| label: get_weights
#| warnings: false
## Get metric weights
# Pull out metric loadings
loadings <- pca_out$weights %>% 
  as.data.frame()

# For each set of loadings, get squares, and then normalized proportions
sq_loadings <- map(loadings, ~ .x^2)
metric_weights <- map(sq_loadings, ~ .x / sum(.x))


## Get component weights
factor_weights <- map(metric_weights, ~ {
  sum_sq_loadings <- c(sum(.x), sum)
})

(sum_sq_loadings <- map_dbl(sq_loadings, ~ sum(.x)))
(factor_weights <- map(sum_sq_loadings, ~ .x / (sum(sum_sq_loadings))))
```

Notes:

- Why is the weight for factor 3 the highest? I thought factor 1 should be
- First, do extraction/scree with as many factors as there are metrics (this doesnt matter actually, we good with 3)
- what is going on with calcs, is it weighting each factor the same??